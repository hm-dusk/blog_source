---
title: 程序员必知的8大排序算法
tags:
  - 算法
  - 排序
comments: true
date: 2017-08-09 22:34:25
categories: 算法
password:
---
程序员必知的8大排序算法
<!-- more -->
8中排序之间的关系
![](http://ot87uvd34.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.JPG)
## 一、插入排序
### 直接插入排序
1. 思想：
在要排序的一堆数组中，假设前面的（n-1）[n>=2]个数已经是排好序的，现在要把第n个数插入到之前的有序数中，使得这n个数也是排好序的。如此反复直到所有的数都排好顺序。
2. 实例：
![](http://ot87uvd34.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%AE%9E%E4%BE%8B.JPG)
3. 用java实现：

```java
public int[] insertSort() {
	int a[] = {4, 2, 3, 1};
	int temp = 0;
	for (int i = 1; i < a.length; i++) {
		//第一次i是第二个元素，第一次是第二个元素和前面比较
		int j = i - 1;
		//temp为当前需要插入的元素
		temp = a[i];
		//j为temp之前的一个元素
		for (; j >= 0 && temp < a[j]; j--) {//如果j还指向数组中的元素（大于等于0），且大于temp
			a[j + 1] = a[j];          //将大于temp的值整体后移一个单位
		}
		a[j + 1] = temp;              //最后将temp放到自己应该存在的位置
	}
	return a;
}

```

### 希尔排序（最小增量排序）
为直接插入排序的改进版，先进行分组的直接插入排序，直到整个数组呈基本有序的情况，再对整个数组进行一次直接插入排序。

1. 思想：
>划分组：把原始组分成多少分（按照每组d个元素分）。
>排序组：每个划分组中的第i个数所组成的组（用于排序）。

	先将要排序的一组数按某个增量d（n/2，n为要排序数的个数，除不尽向上取整）分成若干组（*这里暂且称它为划分组*），每个划分组有d个数据（*最后一组可能小于d*），再取每划分组中对应的元素组成新的组（`每一组的第i个为新的一组，如：每一组的第一个组成一组`，*这里暂且称它为排序组*），对形成的排序组每组作直接插入排序。然后再用较小的增量`d/2`对它进行分划分组、排序组，每个排序组中再进行直接插入排序，直到增量减小到1，再最后进行一次直接插入排序。

2. 实例：
![](http://ot87uvd34.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E5%AE%9E%E4%BE%8B.jpg)
3. 用java实现：

```java
public int[] shellSort() {
	int a[] = {4, 2, 3, 1};
	double d1 = a.length;
	int temp = 0;
	while (true) {
		//算出每一轮的增量
		d1 = Math.ceil(d1/2);
		int d = (int) d1;

		//该循环取得每个需要进行直接插入排序的数组，x为原始数组中的脚标，
		//代表每个组中提取的第几个元素来组成新的分组进行排序
		for (int x = 0; x < d; x++) {
			//该循环为直接插入排序（只是排序的目标数组变成了角标相差为d的数所组成的数组）
			for (int i = x + d; i < a.length; i += d) {
				int j = i - d;
				temp = a[i];
				//直接插入排序的算法，只是将直接插入排序的1抽象为了d
				for (; j >= 0 && temp < a[j]; j -= d) {
					a[j + d] = a[j];        //将需要排序的组中大于temp的向后移（移动单位为d）
				}
				a[j + d] = temp;    //将temp放到它应该在的位置
			}
		}
		if (d == 1) {
			break;
		}
	}
	return a;
}
```
## 二、选择排序
### 简单选择排序
### 堆排序
## 三、交换排序
### 冒泡排序
1. 基本思路：
对需要排序的数组自上而下对相邻的两个数进行比较，让较大的数往下沉，较小的数往上冒。即：每当相邻的两个数不满足要求的排序时，将它们`交换`
2. 实例：
![](http://ot87uvd34.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%AE%9E%E4%BE%8B.jpg)
3. 用java实现：

```java
public int[] bubbleSort(){
		int a[] = {4, 2, 3, 1};

		for(int i = a.length-1 ; i>0 ; i--){
			//比较前面多少位
			for(int j = 0 ; j<i ; j++){
				//从第一位开始，把大的数往后冒
				if(a[j] > a[j+1]){
					int temp = a[j];
					a[j] = a[j+1];
					a[j+1] = temp;
				}
			}
		}
		return a;
	}
```
### 快速排序
## 四、归并排序
## 五、基数排序